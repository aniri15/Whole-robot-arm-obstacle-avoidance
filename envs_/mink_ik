from pathlib import Path

import mujoco
import mujoco.viewer
import numpy as np
from loop_rate_limiters import RateLimiter

import mink
import os

class MinkConfiguration(mink.Configuration):
    """
    Custom configuration class for the Franka Emika Panda robot.
    """
    def __init__(self, model, target,
                 ):
        
        super().__init__(model,
                         )
        self.q = np.zeros(model.nq)  # Joint positions
        self.qvel = np.zeros(model.nv)  # Joint velocities
        self.qacc = np.zeros(model.nv)  # Joint accelerations
        self.model = model
        self.data = mujoco.MjData(model)
        self.target = target
        

    def converge_ik(configuration, tasks, dt, solver, pos_threshold, ori_threshold, max_iters):
        """
        Runs up to 'max_iters' of IK steps. Returns True if position and orientation
        are below thresholds, otherwise False.
        """
        for _ in range(max_iters):
            vel = mink.solve_ik(configuration, tasks, dt, solver, 1e-3)
            configuration.integrate_inplace(vel, dt)

            # Only checking the first FrameTask here (end_effector_task). 
            # If you want to check multiple tasks, sum or combine their errors.
            err = tasks[0].compute_error(configuration)
            pos_achieved = np.linalg.norm(err[:3]) <= pos_threshold
            ori_achieved = np.linalg.norm(err[3:]) <= ori_threshold

            if pos_achieved and ori_achieved:
                return True
        return False

    def mink_ik(self):
        # IK parameters
        SOLVER = "quadprog"
        POS_THRESHOLD = 1e-4
        ORI_THRESHOLD = 1e-4
        MAX_ITERS = 20

        # Create a Mink configuration
        configuration = mink.Configuration(self.model)

        # Define tasks
        end_effector_task = mink.FrameTask(
            frame_name="attachment_site",
            frame_type="site",
            position_cost=1.0,
            orientation_cost=1.0,
            lm_damping=1.0,
        )
        posture_task = mink.PostureTask(model=self.model, cost=1e-2)
        tasks = [end_effector_task, posture_task]

        
        configuration.update(self.data.qpos)
        posture_task.set_target_from_configuration(configuration)
        mujoco.mj_forward(self.model, self.data)

        # Move the mocap target to the end-effector's current pose
        mink.move_mocap_to_frame(self.model, self.data, "goal_site", "attachment_site", "site")
        initial_target_position = self.data.mocap_pos[0].copy()

        # Circular trajectory parameters
        amp = 0.12
        freq = 0.4

        # We'll track time ourselves for a smoother trajectory
        local_time = 0.0
        rate = RateLimiter(frequency=200.0, warn=False)

           
        # Update our local time
        dt = rate.dt
        local_time += dt

        
        self.data.mocap_pos[0] = initial_target_position

        # Update the end effector task target from the mocap body
        T_wt = mink.SE3.from_mocap_name(self.model, self.data, "target")
        end_effector_task.set_target(T_wt)

        # Attempt to converge IK
        converged = self.converge_ik(configuration, tasks, dt, SOLVER,
                                POS_THRESHOLD, ORI_THRESHOLD, MAX_ITERS)

        # Set robot controls (first 8 dofs in your configuration)
        self.data.ctrl = configuration.q[:8]

        # Step simulation
        mujoco.mj_step(self.model, self.data)
        return self.data.ctrl[:8]

            
